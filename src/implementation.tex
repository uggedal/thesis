\chapter{Implementation}
\label{chapter:implementation}

% This chapter should include design choices for my implementation. For
% example choices taken for generating relevant data for test users
% and a computational sound method for doing so. As JavaScript in browsers are
% quite inefficient it will probably be necessary to persist data at a server
% in some sort of cache. The clients could then get this data by invoking a
% single request. The result could for instance be JSON serialized. Scraping
% of such data is probably done more efficient and safer at the server side
% since multiple XMLHttpRequests in the clients for scraping and parsing could
% prove to be quite computational expensive.

As we've seen in 
\sectionref{building.on.top.of.the.web}
it's possible to build applications on top of existing web sites by creating
transparent prototype implementations. This chapter starts with an account of
what kind of navigation system we wanted to build, goes on to describe why we
decided on such navigational designs, and concludes with an explanation of how
the implementation was built\dash{}the ingredients of our implementation.

\section{Design}

\section{Architecture}

\subsection{Client Side}

\subsubsection{Plattform}

\subsubsection{Programming Language}

\subsubsection{Framework}

\subsection{Server Side}

\subsubsection{Plattform}

\subsubsection{Programming Language}

\subsubsection{Framework}

\subsection{Development Tools}

\subsubsection{Version Control}

\subsubsection{Editor}

A developer's main tool for authoring software is his editor. Sometimes the
implementation language warrants a specialized editor with aids for
handeling cumbersome tasks specific to that language. Such editors is often
called \emph{Integrated Development Environments}%
\sidenote{
  A good example of an IDE is
  \emph{Eclipse} (available at \url{http://eclipse.org}).
  It was first used for Java development but since extended with
  plugins for handeling other programming languages and families.
}
(IDEs) and are used most often for languages like Java and C\#.
\citet{murphy06} found that developers mostly use IDEs for navigating large
collections of source code, refactoring code, debugging code, and interacting
with revision control systems in addition to normal editor usage.
Development environments found in Lisp%
\sidenote{
  \prequote[p.~69]{sandewall78}{%
    describes the nature and benefits of the Lisp environment as}{%
      The `residential' design of programing systems, whereby all facilities
      for the user are integrated into one system with which the user
      communicates during the entire interactive session, offers great
      possibilities for user convenience}
}
and Smalltalk%
\sidenote{
  Similar to Lisp's programming environment
  \postquote[p.viii]{goldberg83}{%
    Smalltalk is designed so that every component in the system that is
    accessible to the user can be presented in a meaningful way for
    observation and manipulation}

}
are surpassing IDEs in integration and interactivness even though they
preceded them.

The programming languages we've deciced to work with, JavaScript and Ruby, are
very expressive and dynamic in their nature in addition to beeing interpreted
instead of compiled. Our experience is that IDE usage for such languages
stands more in the way than aid you as a programmer during your problem
solving process.
\citet{bray07} conducted a rather unscientific survey of 1000 Ruby
programmers. Despite of the surveys shortcommings it showed that
the majority of Ruby programmers used non-IDE editors for their
development.

The interactive experience provided by Lisp and Smalltalk implementations are
sadly missing%
\sidenote{
  Ruby has an interactive interpreter similar to those found in Lisp and
  Smalltalk environments called \executable{irb}. It's not integrated into an
  overall programming environment and therefore is mostly used for testing out
  small ideas.
}
from JavaScript and Ruby implementations. This means that we're left with
finding a good editor which enables us to focus on writing code as efficiently
and safely as possible. Editor selection is highly a matter of preference and
finding one that matches your work process. Powerfull editors have a
reputation of beeing quite hard to learn. But if you get over the steap
learning curve the benefits the editor gives you are worth it.
\citeauthor{orenstein08} have experienced how much effort programmers can
invest in something seemingly trivial as an editor:

\begin{citequote}{orenstein08}
  If the thought of switching editors doesn't fill you with quite a bit of
  dread, what you're using now is almost certainly underpowered, and you
  definitely haven't customized it enough.
\end{citequote}


